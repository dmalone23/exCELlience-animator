Model Review: The model interfaces sent to us by the providers were called AnimatorModel and ViewModel. AnimatorModel was an extension of the ViewModel interface. The AnimatorModel was responsible for the functionality that drives the model, while the ViewModel interface was for retrieving data from the model. The design of these two interfaces was straightforward with good Java Documentation; However, some Javadoc comments were vague, indirect, or esoteric and thus were hard to interpret. It was rather easy to integrate with our code after some communication with the provider. The views only rely on the ViewModel interface to retrieve the data from the model, making it very easy to use in our code, as we did not have to shift our own implementation at all. One concern was their use of generic structures that lead to some confusion as previously mentioned. Overall the model interfaces and their supporting interfaces(Shapes and ViewShape) were relatively easy to understand and easy to use with our implementation. We did not need to request any changes to the model interfaces as well as its supporting interfaces.
Controller Review: The provider did not provide us with any interface or information surrounding the controller so there was some guess work needed to determine the controllers functionality, but it was a relatively easy process as the model and view interactions were straightforward enough to understand after a few read throughs.
View Review: In addition to their main view interface, the providers also sent us their three view implementations, respectively titled AnimatorSVGView, AnimatorSwingView,  and AnimatorTextView. The views are overall quite capable for what they are asked to do. The TextualView outputs text to an appendable just as the assignment specifies. The Interactive view works well with both keyboard and button inputs. Overall both of the provided view implementations were very capable. Though initially confusing, the view classes immediately became more convenient to reuse after reviewing with the providers. Similarly, the code was flexible given how they structured the interactions between view and model; sending information to view was minimal and straightforward. Much like their Model and Controller, the code was neatly written and easy to read, though there were some challenges in interpreting the documentation owing to the ambiguity of their language. No changes were requested.
Overall Conclusion: Overall, while some Javadocs and methods/design choices were somewhat difficult to understand, the code ended up being relatively easy to work with. The providers were also very prompt with responses to questions or concerns surrounding their code helping alleviate any confusion promptly. With a few more in depth java docs on certain design choices and implementations the process of implementing the providers code would be a breeze with most implementations of a shapes model.
